//! Event definitions for lambda runtimes and applications.

use std::{
  ops::{
    BitOr,
    BitOrAssign,
  },
  time::Instant,
};

/// A compact bitmask describing coarse event categories.
///
/// The category bits are stable within a major version of `lambda-rs`. Bits
/// outside the defined set are reserved for future expansion and MUST NOT be
/// relied upon.
#[derive(Clone, Copy, Debug, Default, Eq, Hash, PartialEq)]
#[repr(transparent)]
pub struct EventMask(u8);

impl EventMask {
  /// Empty mask (no categories).
  pub const NONE: Self = EventMask(0);

  /// Window events (`Events::Window { .. }`).
  pub const WINDOW: Self = EventMask(1 << 0);

  /// Keyboard events (`Events::Keyboard { .. }`).
  pub const KEYBOARD: Self = EventMask(1 << 1);

  /// Mouse events (`Events::Mouse { .. }`).
  pub const MOUSE: Self = EventMask(1 << 2);

  /// Runtime events (`Events::Runtime { .. }`).
  pub const RUNTIME: Self = EventMask(1 << 3);

  /// Component lifecycle events (`Events::Component { .. }`).
  pub const COMPONENT: Self = EventMask(1 << 4);

  /// Returns `true` when `self` contains every bit set in `other`.
  #[inline]
  pub const fn contains(self, other: Self) -> bool {
    return (self.0 & other.0) == other.0;
  }

  /// Returns a new mask containing the union of `self` and `other`.
  #[inline]
  pub const fn union(self, other: Self) -> Self {
    return EventMask(self.0 | other.0);
  }
}

impl BitOr for EventMask {
  type Output = Self;

  #[inline]
  fn bitor(self, rhs: Self) -> Self::Output {
    return self.union(rhs);
  }
}

impl BitOrAssign for EventMask {
  #[inline]
  fn bitor_assign(&mut self, rhs: Self) {
    *self = self.union(rhs);
  }
}

/// events generated by kernel interactions with the component.
#[derive(Debug, Clone)]
pub enum ComponentEvent {
  Attached { name: String },
  Detached { name: String },
}

/// Window events are generated in response to window events coming from
/// the windowing system.
#[derive(Debug, Clone)]
pub enum WindowEvent {
  Close,
  Resize { width: u32, height: u32 },
}

/// Runtime events are generated by the Runtimes themselves.
#[derive(Debug, Clone)]
pub enum RuntimeEvent {
  Initialized,
  Shutdown,
  ComponentPanic { message: String },
}

/// Exports the winit virtual key codes to this namespace for convenience.
pub use lambda_platform::winit::winit_exports::KeyCode as VirtualKey;

/// Keyboard events are generated in response to keyboard events coming from
/// the windowing system.
#[derive(Debug, Clone)]
pub enum Key {
  /// Emitted when a key is pressed.
  Pressed {
    scan_code: u32,
    virtual_key: Option<VirtualKey>,
  },
  /// Emitted when a key is released.
  Released {
    scan_code: u32,
    virtual_key: Option<VirtualKey>,
  },
  /// Emitted when a modifier key is pressed.
  ModifierPressed {
    modifier: u32,
    virtual_key: VirtualKey,
  },
}

/// Mouse buttons.
#[derive(Debug, Clone)]
pub enum Button {
  Left,
  Right,
  Middle,
  Other(u16),
}

/// Mouse events are generated in response to mouse events coming from the
/// windowing system. The coordinates are in logical pixels.
#[derive(Debug, Clone)]
pub enum Mouse {
  /// Emitted when the mouse cursor is moved within the window.
  Moved {
    x: f64,
    y: f64,
    dx: f64,
    dy: f64,
    device_id: u32,
  },
  /// Emitted when the mouse wheel is scrolled.
  Scrolled { device_id: u32 },
  /// Emitted when a mouse button is pressed.
  Pressed {
    x: f64,
    y: f64,
    button: Button,
    device_id: u32,
  },
  /// Emitted when a mouse button is released.
  Released {
    x: f64,
    y: f64,
    button: Button,
    device_id: u32,
  },
  /// Emitted when the mouse cursor leaves the window.
  LeftWindow { device_id: u32 },
  /// Emitted when the mouse cursor enters the window.
  EnteredWindow { device_id: u32 },
}

/// Generic Event Enum which encapsulates all possible events that will be
/// emitted by the LambdaKernel
#[derive(Debug, Clone)]
pub enum Events {
  Component {
    event: ComponentEvent,
    issued_at: Instant,
  },
  Window {
    event: WindowEvent,
    issued_at: Instant,
  },
  Runtime {
    event: RuntimeEvent,
    issued_at: Instant,
  },
  Keyboard {
    event: Key,
    issued_at: Instant,
  },
  Mouse {
    event: Mouse,
    issued_at: Instant,
  },
}

impl Events {
  /// Returns the event category mask for this event variant.
  #[inline]
  pub fn mask(&self) -> EventMask {
    let mask = match self {
      Events::Component { .. } => EventMask::COMPONENT,
      Events::Window { .. } => EventMask::WINDOW,
      Events::Runtime { .. } => EventMask::RUNTIME,
      Events::Keyboard { .. } => EventMask::KEYBOARD,
      Events::Mouse { .. } => EventMask::MOUSE,
    };
    return mask;
  }
}

#[cfg(test)]
mod tests {
  use super::*;

  #[test]
  fn event_mask_contains_none_behavior() {
    assert!(EventMask::NONE.contains(EventMask::NONE));
    assert!(!EventMask::NONE.contains(EventMask::WINDOW));
  }

  #[test]
  fn event_mask_union_associativity_multiple_categories() {
    let left = EventMask::WINDOW
      .union(EventMask::KEYBOARD)
      .union(EventMask::MOUSE);
    let right =
      EventMask::WINDOW.union(EventMask::KEYBOARD.union(EventMask::MOUSE));
    assert_eq!(left, right);
  }

  #[test]
  fn event_mask_contains_present_and_absent_categories() {
    let mask = EventMask::WINDOW.union(EventMask::KEYBOARD);
    assert!(mask.contains(EventMask::WINDOW));
    assert!(mask.contains(EventMask::KEYBOARD));
    assert!(!mask.contains(EventMask::MOUSE));
  }

  #[test]
  fn events_mask_maps_each_variant() {
    let component = Events::Component {
      event: ComponentEvent::Attached {
        name: "test".to_string(),
      },
      issued_at: Instant::now(),
    };
    assert_eq!(component.mask(), EventMask::COMPONENT);

    let window = Events::Window {
      event: WindowEvent::Close,
      issued_at: Instant::now(),
    };
    assert_eq!(window.mask(), EventMask::WINDOW);

    let runtime = Events::Runtime {
      event: RuntimeEvent::Initialized,
      issued_at: Instant::now(),
    };
    assert_eq!(runtime.mask(), EventMask::RUNTIME);

    let keyboard = Events::Keyboard {
      event: Key::Pressed {
        scan_code: 0,
        virtual_key: None,
      },
      issued_at: Instant::now(),
    };
    assert_eq!(keyboard.mask(), EventMask::KEYBOARD);

    let mouse = Events::Mouse {
      event: Mouse::Scrolled { device_id: 0 },
      issued_at: Instant::now(),
    };
    assert_eq!(mouse.mask(), EventMask::MOUSE);
  }
}
