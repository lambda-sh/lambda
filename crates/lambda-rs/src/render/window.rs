//! Window construction and handle wrapper for rendering applications.
//!
//! This module wraps a `winit` window with sizing metadata and provides a
//! builder used by runtimes to create a window before constructing a
//! `RenderContext`.

use lambda_platform::winit::{
  Loop,
  WindowHandle,
  WindowHandleBuilder,
  WindowProperties,
};

use crate::events::Events;

/// Builder for windows that are used to render a frame within the
/// RenderContext.
pub struct WindowBuilder {
  name: String,
  dimensions: (u32, u32),
  vsync: bool,
}

impl Default for WindowBuilder {
  fn default() -> Self {
    return Self::new();
  }
}

impl WindowBuilder {
  /// A new window builder will be 480x360 by default and have the name
  /// "Window". After customizing the window with whatever properties your
  /// application needs, you can supply it an event loop to process the
  /// events that will be generated by the window.
  pub fn new() -> Self {
    return Self {
      name: String::from("Window"),
      dimensions: (480, 360),
      vsync: true,
    };
  }

  /// The name to be displayed in the title bar of the window.
  pub fn with_name(mut self, name: &str) -> Self {
    self.name = name.to_string();
    return self;
  }

  /// Specify the dimensions for the window (Defaults to 480 x 360).
  pub fn with_dimensions(mut self, width: u32, height: u32) -> Self {
    self.dimensions = (width, height);
    return self;
  }

  /// Request vertical sync behavior for the swapchain.
  ///
  /// This value is consumed when building a `RenderContext` if no explicit
  /// present mode is provided to `RenderContextBuilder`.
  ///
  /// Disabling vsync is bestâ€‘effort; the final present mode depends on the
  /// platform and adapter surface capabilities.
  pub fn with_vsync(mut self, vsync: bool) -> Self {
    self.vsync = vsync;
    return self;
  }

  // TODO(vmarcella): Remove new call for window and construct the window directly.
  pub fn build(self, event_loop: &mut Loop<Events>) -> Window {
    return Window::new(
      self.name.as_str(),
      self.dimensions,
      self.vsync,
      event_loop,
    );
  }
}

/// Window implementation for rendering applications.
pub struct Window {
  window_handle: WindowHandle,
  vsync: bool,
}

impl Window {
  fn new(
    name: &str,
    dimensions: (u32, u32),
    vsync: bool,
    event_loop: &mut Loop<Events>,
  ) -> Self {
    let window_properties = WindowProperties {
      name: name.to_string(),
      dimensions,
    };

    let window_handle = WindowHandleBuilder::new()
      .with_window_properties(window_properties, event_loop)
      .build();

    logging::debug!("Created window: {}", name);
    return Self {
      window_handle,
      vsync,
    };
  }

  /// Redraws the window.
  pub fn redraw(&self) {
    self.window_handle.window_handle.request_redraw();
  }

  /// Returns the window handle.
  pub fn window_handle(&self) -> &WindowHandle {
    return &self.window_handle;
  }

  /// Returns the dimensions of the current window. (width, height)
  pub fn dimensions(&self) -> (u32, u32) {
    return (
      self.window_handle.size.width,
      self.window_handle.size.height,
    );
  }

  /// Returns the requested vertical sync preference for presentation.
  pub fn vsync_requested(&self) -> bool {
    return self.vsync;
  }
}

#[cfg(test)]
mod tests {
  #[cfg(not(target_os = "macos"))]
  use lambda_platform::winit::LoopBuilder;

  use super::*;

  /// Ensures `WindowBuilder` initializes with stable, sensible defaults.
  #[test]
  fn window_builder_defaults_are_sensible() {
    let builder = WindowBuilder::new();
    assert_eq!(builder.name, "Window");
    assert_eq!(builder.dimensions, (480, 360));
    assert!(builder.vsync);
  }

  /// Ensures the fluent builder setters update the stored window properties.
  #[test]
  fn window_builder_allows_overriding_properties() {
    let builder = WindowBuilder::new()
      .with_name("Hello")
      .with_dimensions(800, 600)
      .with_vsync(false);

    assert_eq!(builder.name, "Hello");
    assert_eq!(builder.dimensions, (800, 600));
    assert!(!builder.vsync);
  }

  /// Best-effort window construction smoke test for environments that support
  /// window creation (skips on macOS test threads and in headless runners).
  #[test]
  #[cfg(not(target_os = "macos"))]
  fn window_build_is_best_effort_in_headless_envs() {
    let attempt =
      std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        let mut event_loop = LoopBuilder::new().build();
        WindowBuilder::new()
          .with_name("lambda-window-test")
          .with_dimensions(10, 20)
          .with_vsync(true)
          .build(&mut event_loop)
      }));

    let window = match attempt {
      Ok(window) => window,
      Err(_) => return, // likely headless environment
    };

    assert_eq!(window.dimensions(), (10, 20));
    assert!(window.vsync_requested());
  }
}
