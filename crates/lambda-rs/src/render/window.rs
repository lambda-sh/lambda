//! Window construction and handle wrapper for rendering applications.
//!
//! This module wraps a `winit` window with sizing metadata and provides a
//! builder used by runtimes to create a window before constructing a
//! `RenderContext`.

use lambda_platform::winit::{
  Loop,
  WindowHandle,
  WindowHandleBuilder,
  WindowProperties,
};

use crate::events::Events;

/// Builder for windows that are used to render a frame within the
/// RenderContext.
pub struct WindowBuilder {
  name: String,
  dimensions: (u32, u32),
  vsync: bool,
}

impl WindowBuilder {
  /// A new window builder will be 480x360 by default and have the name
  /// "Window". After customizing the window with whatever properties your
  /// application needs, you can supply it an event loop to process the
  /// events that will be generated by the window.
  pub fn new() -> Self {
    return Self {
      name: String::from("Window"),
      dimensions: (480, 360),
      vsync: false,
    };
  }

  /// The name to be displayed in the title bar of the window.
  pub fn with_name(mut self, name: &str) -> Self {
    self.name = name.to_string();
    return self;
  }

  /// Specify the dimensions for the window (Defaults to 480 x 360).
  pub fn with_dimensions(mut self, width: u32, height: u32) -> Self {
    self.dimensions = (width, height);
    return self;
  }

  /// Request vertical sync behavior for the swapchain.
  ///
  /// Note: present mode is ultimately selected when configuring the rendering
  /// surface in `RenderContextBuilder`. This flag is reserved to influence
  /// that choice and is currently a noâ€‘op.
  pub fn with_vsync(mut self, vsync: bool) -> Self {
    self.vsync = vsync;
    return self;
  }

  // TODO(vmarcella): Remove new call for window and construct the window directly.
  pub fn build(self, event_loop: &mut Loop<Events>) -> Window {
    return Window::new(self.name.as_str(), self.dimensions, event_loop);
  }
}

/// Window implementation for rendering applications.
pub struct Window {
  window_handle: WindowHandle,
}

impl Window {
  fn new(
    name: &str,
    dimensions: (u32, u32),
    event_loop: &mut Loop<Events>,
  ) -> Self {
    // Attempt to get the primary monitor first and then falls back to the first
    // available monitor if that isn't found.
    let monitor_handle = event_loop.get_primary_monitor().unwrap_or(
      event_loop
        .get_any_available_monitors()
        .expect("No monitors available"),
    );

    let window_properties = WindowProperties {
      name: name.to_string(),
      dimensions,
      monitor_handle,
    };

    let window_handle = WindowHandleBuilder::new()
      .with_window_properties(window_properties, event_loop)
      .build();

    logging::debug!("Created window: {}", name);
    return Self { window_handle };
  }

  /// Redraws the window.
  pub fn redraw(&self) {
    self.window_handle.window_handle.request_redraw();
  }

  /// Returns the window handle.
  pub fn window_handle(&self) -> &WindowHandle {
    return &self.window_handle;
  }

  /// Returns the dimensions of the current window. (width, height)
  pub fn dimensions(&self) -> (u32, u32) {
    return (
      self.window_handle.size.width,
      self.window_handle.size.height,
    );
  }
}
